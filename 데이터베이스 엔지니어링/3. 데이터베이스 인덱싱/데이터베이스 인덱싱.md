# 데이터베이스 인덱싱

# 25.04.24

백만 개의 행이 있는 Postgres 테이블 만들기

- `create table temp(t int)`
- `insert into temp(t) select random() * 100 from generate_series(0, 1000000)`

# 25.04.28

인덱스(Index)

- 기존 테이블 위에 구축하고 할당하는 데이터 구조로, 테이블을 조회하고 분석하여 요약한 일종의 지름길
    - B-트리와 LSM트리로 2가지 유형

![image.png](image.png)

- id는 인덱스이므로 id를 조회할 때에는 찾는 속도가 매우 빠름 ⇒ heap(실제 데이터가 있는 곳)에서 찾을 필요가 없기 때문

![image.png](image%201.png)

- name이라는 필드는 인덱스에 없기 때문에 heap에서 실제 데이터를 찾는 과정이 필요

![image.png](image%202.png)

- name을 조회하는 쿼리를 한 번 더 수행하면 속도가 더 빨라진 것을 볼 수 있는데, 이는 캐싱을 하기 때문

![image.png](image%203.png)

![image.png](image%204.png)

- where절에서 name은 인덱스에 없고, 실제 이름 값 Zs를 찾기 위해 직원  테이블을 하나씩 하나씩 순차적으로 스캔

![image.png](image%205.png)

- name 필드에 대한 인덱스 생성

![image.png](image%206.png)

- name 필드에 대한 인덱스를 생성한 후, 다시 쿼리를 실행해보면 속도가 더 빨라진 것을 확인할 수 있음

![image.png](image%207.png)

- where절에서 정확한 값이 아닌 like를 사용한 표현식으로 바꿔서 수행

![image.png](image%208.png)

- name 필드는 인덱스가 있지만 정확한 값이 아닌 표현식으로 요청했기 때문에 모든 데이터를 순차적으로 스캔하여 시간이 오래 걸림

Explain으로 SQL 쿼리 플래너와 옵티마이저 이해하기

- 아래와 같은 테이블과 인덱스가 있다고 가정

| Column | Type | Collation | Nullable | Default |
| --- | --- | --- | --- | --- |
| id | integer |  | not null | nextval(’grades_id_seq’::regclass) |
| g | double precision |  |  |  |
| name | text |  |  |  |
- Indexes:
    - “g_idx” btree (g)
    - “id_idx” btree(id)

- explain select * from grades;
    - 결과
        - Seq Scan on grades (cost=0.00..289025.15 rows=121412125 width=31) (1 row)
    - 결과 분석
        - Seq Scan: 순차 스캔 ⇒ 다른 DB에서는 전체 테이블 스캔과 동등
        - cost에서 첫 번째 숫자는 첫 번째 페이지를 가져오는데 드는 비용, 두 번째 숫자는 데이터베이스가 미리 예상하는 총 비용
        - width: 모든 열의 바이트 합계

- explain select * from grades order by g;
    - 결과
        - Index Scan using g_idx on grades (cost=0.43..1257856.88 rows=12141215 width=31) (1 row)
    - 결과 분석
        - cost를 보면, 첫 번째 페이지를 가져오는데 0.43만큼의 비용이 소요됨 ⇒ g는 인덱스가 있기 때문에 g를 기준으로 정렬하는 것은 매우 사소한 작업임

- explain select * from grades order by name;
    - 결과
        - Gather Merge (cost=1024586.74..2205065.16 rows=10117680 width=31)
        - Workers Planned: 2
        - → Sort (cost=1023586.72..1036233.82 rows=5058840 width=31)
        - Sort Key: name
        - → Parallel Seq Scan on grades (cost=0.00..218201.40 rows=5058840 width=31) (5rows)
    - 결과 분석
        - grades테이블을 순차 스캔, 5058840개의 행을 반환, 행의 평균 너비 31
        - 5058840개의 행을 이름 기준으로 정렬
        - 2개의 워커가 일함
        - 2개의 워커가 병렬로 스캔한 데이터를 유지하면서 병합(merge)

- explain select id from grades;
    - 결과
        - Seq Scan on grades (cost=0.00..289025.15 rows=12141215 width=4)
        - JIT:
        - Functions: 2
        - Options: Inlining false, Optimization false, Expressions true, Deforming true (4 rows)
    - 결과 분석
        - grades 테이블을 순차 스캔, 12141215개의 행 반환, 행의 평균 너비 = 4
        - JIT 컴파일 사용
        - Functions: 2 ⇒ JIT 컴파일 된 함수는 2개
        - Inlining ⇒ JIT(Just-In-Time) 컴파일러가 함수 호출을 최적화하여 성능을 개선, JIT 컴파일은 작은 함수의 본문을 해당 함수를 사용하는 표현식에 인라인으로 삽입
        - Optimization ⇒ LLVM은 생성된 코드 최적화를 지원. 일부 최적화는 JIT을 사용할 때마다 수행할 수 있을 만큼 비용이 저렴하지만, 다른 최적화는 장기 실행 쿼리에만 효과적
            - LLVM: 모듈화되고 재사용 가능한 컴파일러와 툴체인 기술의 집합체
        - Expressions ⇒ SQL 표현식에 대해 JIT 적용
        - Deforming ⇒ 테이블의 Row를 튜플 구조로 해석할 때 JIT을 사용

- explain select name from grades;
    - 결과
        - Seq Scan on grades (cost=0.00..289025.15 rows=12141215 width=19)
        - JIT:
        - Functions: 2
        - Options: Inlining false, Optimization false, Expressions true, Deforming true (4 rows)
    - 결과 분석
        - 행의 평균 너비 19

- explain select g from grades;
    - 결과
        - Seq Scan on grades (cost=0.00..289025.15 rows=12141215 width=8)
        - JIT:
        - Functions: 2
        - Options: Inlining false, Optimization false, Expressions true, Deforming true (4 rows)
    - 결과 분석
        - 행의 평균 너비 8

- explain select * from grades where id = 10;
    - 결과
        - Index Scan using id_idx on grades (cost=0.43..8.45 rows=1 width=31)
        - Index Cond: (id = 10) (2 rows)
    - 결과 분석
        - where절에서 id는 인덱스가 있으므로 실행 비용이 매우 낮음

- explain select id from grades where id = 10;
    - 결과
        - Index Only Scan using id_idx on grades (cost=0.43..4.45 rows=1 width=4)
        - Index Cond: (id = 10) (2 rows)
    - 결과 분석
        - where절에서 id는 인덱스가 있고, 조회할 데이터도 id이므로 인덱스에서만 찾아도 되므로 위의 쿼리보다 실행 비용은 더 낮음

비트맵 인덱스 스캔 vs 인덱스 스캔 vs 테이블 스캔

| Column | Type | Collation | Nullable | Default |
| --- | --- | --- | --- | --- |
| id | integer |  | not null | nextval(’grades_id_seq’::regclass) |
| name | text |  |  |  |
| g | double |  |  |  |
| firstname | text |  |  |  |
| lastname | text |  |  |  |
| address | text |  |  |  |
| bio | text |  |  |  |
- Indexes:
    - “grades_pkey” PRIMARY KEY, btree (id)
    - “g” btree (g) INCLUDE (id)

- explain select name from grades where
    - 결과
        - Index Scan using grades_pkey on grades (cost=0.43..8.45 rows=1 width=4)
        - Index Cond: (id = 1000) (2 rows)

- explain select name from grades where id < 100;
    - 결과
        - Index Scan using grades_pkey on grades (cost=0.43..391.13 rows=98 width=4)
        - Index Cond: (id < 100) (2 rows)

- explain select name from grades where id > 100;
    - 결과
        - Seq Scan on grades (cost=0.00..134265.34 rows=5000248 width=4)
        - Filter: (id > 100)
        - JIT:
        - Functions: 4
        - Options: Inlining false, Optimization false, Expressions true, Deforming true (5 rows)

- explain select name from grades where g > 95;
    - 결과
        - Bitmap Heap Scan on grades (cost=3859.77..110758.53 rows=205850 width=4)
        - Recheck Cond: (g > 95)
        - → Bitmap Index Scan on g (cost=0.00..3808.31 rows=205850 width=0)
        - Index Cond: (g > 95)
        - JIT:
        - Functions: 4
        - Options: Inlining false, Optimization false, Expressions true, Deforming true (7 rows)
    - 결과 분석
        - Bitmap Index Scan ⇒ 인덱스를 스캔하여 어떤 페이지에 찾고자 하는 행이 있는지 확인하여 bitmap을 생성
        - bitmap을 만드는 과정에서 탐색할 페이지를 확인했어도, 그 중 일부는 조건을 만족하지 못할 수 있음(각 페이지에는 한 줄의 데이터만 있는 것이 아니므로…) ⇒ 조건을 다시 확인하여 불필요한 데이터 제거

- explain select name from grades where g > 95 and id < 10000;
    - 결과
        - Bitmap Heap Scan on grades (cost=3988.96..5497.62 rows=394 width=4)
        - Recheck Cond: ((id < 10000) and (g > 95))
        - → BitmapAnd (cost=3988.96..3988.96 rows=394 width=0)
        - → Bitmap Index Scan on grades_pkey (cost=0.00..180.21 rows=9570 width=0)
        - Index Cond: (id < 10000)
        - → Bitmap Index Scan on g (cost=0.00..3808.31 rows=205850 width=0)
        - Index Cond: (g > 95) (7 rows)
    - 결과 분석
        - Bitmap Index Scan ⇒ 인덱스를 스캔하여 어떤 페이지에 찾고자 하는 행이 있는지 확인하여 bitmap을 생성
            - 조건이 2개이고, 각 조건에 쓰인 필드는 각각의 인덱스를 가지고 있음 ⇒ 2개의 필드에 대해서 Bitmap Index Scan을 진행 후, 서로 겹치는 페이지가 있는 것만 방문하도록 함
        - bitmap을 만드는 과정에서 탐색할 페이지를 확인했어도, 그 중 일부는 조건을 만족하지 못할 수 있음(각 페이지에는 한 줄의 데이터만 있는 것이 아니므로…) ⇒ 조건을 다시 확인하여 불필요한 데이터 제거
